# -*- coding: utf-8 -*-
"""CS7CS4_GroupProject_Preprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1scUSa4gXNTY8_TxZGoAVr--Lz7KL52lo
"""

import numpy as np
import pandas as pd
import math as mt
import matplotlib.pyplot as plt

#~~~~ Import input csvs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# Cut out all columns but name, latitude, and longitude

acc = pd.read_csv("Accommodation.csv", usecols=[0,3,4])
print(acc.head(),"\n")
act = pd.read_csv("Activities.csv", usecols=[0,3,4])
print(act.head(),"\n")
att = pd.read_csv("Attractions.csv", usecols=[0,3,4])
print(att.head(),"\n")

#~~~~ Function to find distance between two coordinate points ~~~~~~~~~~~~~~~~~#
# Use Haversine formula from https://www.movable-type.co.uk/scripts/latlong.html

def haversineDistance(lat1, lon1, lat2, lon2):
  R = 6371000.0                         # Radius of the Earth in metres
  radLat1 = lat1 * np.pi/180            # Latitude in radians
  radLat2 = lat2 * np.pi/180
  radLatDelta = (lat2 - lat1) * np.pi/180
  radLonDelta = (lon2 - lon1) * np.pi/180

  x = mt.sin(radLatDelta/2) * mt.sin(radLatDelta/2)   # sin^2 of lat distance
  y = mt.sin(radLonDelta/2) * mt.sin(radLonDelta/2)   # sin^2 of lon distance
  a = x + mt.cos(radLat1) * mt.cos(radLat2) * y
  c = 2 * mt.atan2(mt.sqrt(a), mt.sqrt(1-a))
  d = R * c                                           # Distance in metres

  return d

#~~~~ Define grid ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

latCentres = np.linspace(51,56,90)
lonCentres = np.linspace(-5,-11,70)

#~~~~ Define and count points in circles ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

trainingData = pd.DataFrame()

for i in latCentres:
  for j in lonCentres:
    tempAcc = acc[acc['Latitude'].between(i-0.05555,i+0.05555)]
    tempAcc = tempAcc[tempAcc['Longitude'].between(j-0.08571,j+0.08571)]
    countAcc = 0
    for index, row in tempAcc.iterrows():
      if haversineDistance(i,j,row['Latitude'],row['Longitude']) < 5000:
        countAcc = countAcc + 1
    tempAct = act[act['Latitude'].between(i-0.05555,i+0.05555)]
    tempAct = tempAct[tempAct['Longitude'].between(j-0.08571,j+0.08571)]
    countAct = 0
    for index, row in tempAct.iterrows():
      if haversineDistance(i,j,row['Latitude'],row['Longitude']) < 5000:
        countAct = countAct + 1
    tempAtt = att[att['Latitude'].between(i-0.05555,i+0.05555)]
    tempAtt = tempAtt[tempAtt['Longitude'].between(j-0.08571,j+0.08571)]
    countAtt = 0
    for index, row in tempAtt.iterrows():
      if haversineDistance(i,j,row['Latitude'],row['Longitude']) < 5000:
        countAtt = countAtt + 1

    temp_df = pd.DataFrame(data=[[i, j, countAtt, countAct, countAcc]], columns=['Centre Latitude', 'Centre Longitude', 'Attractions', 'Activities', 'Accommodation'])
    trainingData = trainingData.append(temp_df, ignore_index=True)

print("\nTraining Data:\n")
print(trainingData.head())

#~~~~ Graph features against each other to check suitability ~~~~~~~~~~~~~~~~~~#
X1 = trainingData.iloc[:, 2]
X2 = trainingData.iloc[:, 3]
Y = trainingData.iloc[:, 4]

plt.rc('font', size=18)
plt.rcParams['figure.constrained_layout.use'] = True
plt.axes(label = "background").set_facecolor('#eeeeff')
plt.scatter(X1, Y, color='#00a714', marker='+')
plt.xlabel("Number of Attractions"); plt.ylabel("Number of Accommodations")
plt.show()

plt.rc('font', size=18)
plt.rcParams['figure.constrained_layout.use'] = True
plt.axes(label = "background").set_facecolor('#eeeeff')
plt.scatter(X2, Y, color='#0754a7', marker='o')
plt.xlabel("Number of Activities"); plt.ylabel("Number of Accommodations")
plt.show()

plt.rc('font', size=18)
plt.rcParams['figure.constrained_layout.use'] = True
plt.axes(label = "background").set_facecolor('#eeeeff')
plt.scatter(X1, Y, color='#00a714', marker='+')
plt.xlim(0, 23)
plt.ylim(0,120)
plt.xlabel("Number of Attractions"); plt.ylabel("Number of Accommodations")
plt.show()

plt.rc('font', size=18)
plt.rcParams['figure.constrained_layout.use'] = True
plt.axes(label = "background").set_facecolor('#eeeeff')
plt.scatter(X2, Y, color='#0754a7', marker='o')
plt.xlim(0,250)
plt.ylim(0,120)
plt.xlabel("Number of Activities"); plt.ylabel("Number of Accommodations")
plt.show()